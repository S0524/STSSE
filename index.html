<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>尖塔存档修改工具</title>
    <style>
        /* 基础样式重置 */
        html, body {
            height: 100%;
            overflow: auto;
            margin: 0;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: "微软雅黑", "宋体", sans-serif; }
        
        /* 页面主体样式 */
        body { 
            background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%); 
            min-height: 100vh; 
            padding: 15px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        
        /* 主容器样式 */
        .app-container { 
            width: 100%; 
            max-width: 1000px; 
            background: #ffffff; 
            border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(138, 173, 255, 0.1); 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
        }
        
        /* 标题样式 */
        .app-title { text-align: center; color: #2d4166; font-size: 24px; font-weight: 700; letter-spacing: 0.3px; }
        
        /* 文件上传区域 */
        .upload-section { width: 100%; padding: 15px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; }
        #fileInput { width: 100%; padding: 9px 12px; border: 1px solid #cbd5e1; border-radius: 6px; background: #ffffff; cursor: pointer; transition: border-color 0.2s; font-size: 14px; }
        #fileInput:hover, #fileInput:focus { border-color: #60a5fa; outline: none; }
        
        /* 文本域容器 */
        .textareas-container { width: 100%; }
        textarea { 
            width: 100%; 
            height: 220px; 
            padding: 15px; 
            border: 1px solid #e2e8f0; 
            border-radius: 8px; 
            resize: vertical; 
            font-size: 14px; 
            line-height: 1.6; 
            background: #ffffff; 
            color: #1e293b; 
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02); 
            transition: border-color 0.2s; 
        }
        textarea:focus { outline: none; border-color: #60a5fa; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02), 0 0 0 3px rgba(96, 165, 250, 0.1); }
        textarea::placeholder { color: #94a3b8; }
        
        /* 按钮组样式 */
        .btn-group { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .func-btn { 
            padding: 10px 18px; 
            border: none; 
            border-radius: 6px; 
            background: #64748b; 
            color: #ffffff; 
            font-size: 13px; 
            font-weight: 500; 
            cursor: pointer; 
            transition: background 0.2s; 
        }
        .func-btn:hover { background: #475569; }
        .func-btn.主要功能 { background: #3b82f6; }
        .func-btn.主要功能:hover { background: #2563eb; }
        .func-btn.下载 { background: #10b981; padding: 11px 28px; font-size: 15px; font-weight: 600; }
        .func-btn.下载:hover { background: #059669; }
        .func-btn.复制 { background: #8b5cf6; }
        .func-btn.复制:hover { background: #7c3aed; }
        
        /* 弹窗样式 */
        .custom-alert {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            pointer-events: none;
            display: none;
        }
        .custom-alert .alert-content {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            padding: 25px 30px;
            width: 85%;
            max-width: 350px;
            text-align: center;
            pointer-events: auto;
        }
        .custom-alert-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d4166;
            margin-bottom: 12px;
        }
        .custom-alert-text {
            font-size: 15px;
            color: #475569;
            margin-bottom: 20px;
        }
        .custom-alert-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }
        .custom-alert-btn:hover { background: #2563eb; }
        
        /* 遮罩层样式 */
        .alert-mask {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9998;
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <h1 class="app-title">尖塔存档修改工具</h1>
        <div class="upload-section">
            <input type="file" id="fileInput" title="选择存档文件" onchange="readFile()">
        </div>
        <div class="textareas-container">
            <textarea id="inputJson" placeholder="选择文件后自动显示内容..."></textarea>
        </div>
        <div class="btn-group">
            <button class="func-btn" onclick="modifyNums()">修改数值</button>
            <button class="func-btn" onclick="addRelics()">添加遗物</button>
            <button class="func-btn" onclick="delCurse()">删除诅咒</button>
            <button class="func-btn" onclick="upgradeCards()">升级卡牌</button>
            <button class="func-btn 主要功能" onclick="oneClickOpt()">一键优化</button>
            <button class="func-btn" onclick="delAttack()">删除攻击</button>
            <button class="func-btn" onclick="delDefend()">删除防御</button>
            <button class="func-btn 复制" onclick="copyResult()">复制结果</button>
            <button class="func-btn 下载" onclick="downloadFile()">下载文件</button>
        </div>
        <div class="textareas-container">
            <textarea id="outputJson" placeholder="修改后的结果会显示在这里..."></textarea>
        </div>
    </div>

    <div class="alert-mask" id="alertMask"></div>
    <div class="custom-alert" id="customAlert">
        <div class="alert-content">
            <div class="custom-alert-title">操作提示</div>
            <div class="custom-alert-text" id="alertText">复制成功</div>
            <button class="custom-alert-btn" onclick="hideAlert()">确定</button>
        </div>
    </div>

    <script>
        // 核心DOM元素
        const inputEl = document.getElementById('inputJson');
        const outputEl = document.getElementById('outputJson');
        const fileInput = document.getElementById('fileInput');
        const customAlert = document.getElementById('customAlert');
        const alertMask = document.getElementById('alertMask');
        const alertText = document.getElementById('alertText');
        
        // 配置项
        const ENCRYPTION_KEY = 'key';
        let originalFileName = '';
        let isEncrypted = false;
        const curseIds = ['AscendersBane','CurseOfTheBell','Necronomicurse','Pride','Clumsy','Decay','Doubt','Injury','Normality','Pain','Parasite','Regret','Shame','Writhe'];
        const targetRelics = ['Molten Egg 2','Toxic Egg 2','Frozen Egg 2','Smiling Mask','The Courier','Black Star','WingedGreaves','Membership Card','Omamori','Girya','Dream Catcher','Peace Pipe','Shovel'];
        const attackIds = ['Strike_R', 'Strike_G', 'Strike_B', 'Strike_P'];
        const defendIds = ['Defend_R', 'Defend_G', 'Defend_B', 'Defend_P'];
        const countRelics = { 'WingedGreaves': 99, 'Omamori': 99 };
        const relicLists = ['relics', 'common_relics', 'uncommon_relics', 'rare_relics', 'shop_relics', 'boss_relics'];

        // 弹窗控制
        function showAlert(text) {
            alertText.innerText = text;
            customAlert.style.display = 'flex';
            alertMask.style.display = 'block';
        }
        function hideAlert() {
            customAlert.style.display = 'none';
            alertMask.style.display = 'none';
        }

        // 异或加解密核心方法
        function xorWithKey(data, key) {
            const keyLen = key.length;
            return new Uint8Array(data.map((byte, i) => byte ^ key[i % keyLen]));
        }

        // 解密存档内容
        function decode(encodedStr) {
            try {
                const safeStr = encodedStr.trim().replace(/-/g, '+').replace(/_/g, '/');
                const base64Dec = Uint8Array.from(atob(safeStr), c => c.charCodeAt(0));
                const keyBytes = new TextEncoder().encode(ENCRYPTION_KEY);
                const decBytes = xorWithKey(base64Dec, keyBytes);
                return new TextDecoder('utf-8').decode(decBytes);
            } catch (e) {
                return null;
            }
        }

        // 加密存档内容
        function encode(originalStr) {
            try {
                const originalBytes = new TextEncoder().encode(originalStr);
                const keyBytes = new TextEncoder().encode(ENCRYPTION_KEY);
                const encBytes = xorWithKey(originalBytes, keyBytes);
                return btoa(String.fromCharCode(...encBytes)).replace(/\+/g, '-').replace(/\//g, '_');
            } catch (e) {
                throw new Error(`加密失败：${e.message}`);
            }
        }

        // 判断存档是否加密并解析
        function judgeSave(fileContent) {
            const decJson = decode(fileContent);
            if (decJson) {
                try {
                    JSON.parse(decJson);
                    return { isEncrypted: true, jsonStr: decJson };
                } catch (e) {
                    return { isEncrypted: false, jsonStr: fileContent };
                }
            }
            try {
                JSON.parse(fileContent.trim());
                return { isEncrypted: false, jsonStr: fileContent.trim() };
            } catch (e) {
                throw new Error('文件无效：非加密存档或有效JSON');
            }
        }

        // 读取上传的存档文件
        function readFile() {
            const file = fileInput.files[0];
            if (!file) return;
            originalFileName = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const { isEncrypted: encStatus, jsonStr } = judgeSave(content);
                    isEncrypted = encStatus;
                    const parsed = JSON.parse(jsonStr);
                    inputEl.value = jsonStr;
                    outputEl.value = JSON.stringify(parsed, null, 2);
                } catch (e) {
                    showAlert(e.message);
                    inputEl.value = '';
                    outputEl.value = '';
                }
            };
            reader.onerror = function() {
                showAlert('文件读取失败');
                inputEl.value = '';
                outputEl.value = '';
            };
            reader.readAsText(file, 'utf-8');
        }

        // 获取解析后的JSON对象
        function getJson() {
            try {
                const val = outputEl.value.trim();
                if (!val) throw new Error('请先上传文件');
                return JSON.parse(val);
            } catch (e) {
                showAlert(`JSON错误：${e.message}`);
                return null;
            }
        }

        // 修改基础数值（金币、血量等）
        function modifyNums() {
            const obj = getJson();
            if (!obj) return;
            obj.gold = 999;
            obj.red = 10;
            obj.max_health = 99;
            obj.current_health = 99;
            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 添加指定遗物和钥匙
        function addRelics() {
            const obj = getJson();
            if (!obj) return;

            relicLists.forEach(list => {
                if (!Array.isArray(obj[list])) obj[list] = [];
            });

            targetRelics.forEach(relic => {
                if (!obj.relics.includes(relic)) obj.relics.push(relic);
            });

            if (!Array.isArray(obj.relic_counters)) obj.relic_counters = [];
            while (obj.relic_counters.length < obj.relics.length) {
                obj.relic_counters.push(-1);
            }

            Object.entries(countRelics).forEach(([name, count]) => {
                const idx = obj.relics.indexOf(name);
                if (idx !== -1) obj.relic_counters[idx] = count;
            });

            relicLists.slice(1).forEach(list => {
                obj[list] = obj[list].filter(item => !targetRelics.includes(item));
            });

            obj.has_ruby_key = true;
            obj.has_emerald_key = true;
            obj.has_sapphire_key = true;

            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 删除诅咒卡牌
        function delCurse() {
            const obj = getJson();
            if (!obj) return;
            if (!Array.isArray(obj.cards)) obj.cards = [];
            obj.cards = obj.cards.filter(card => !curseIds.includes(card.id));
            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 升级所有卡牌
        function upgradeCards() {
            const obj = getJson();
            if (!obj) return;
            if (!Array.isArray(obj.cards)) obj.cards = [];
            obj.cards.forEach(card => card.upgrades = 1);
            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 一键优化存档（整合所有修改）
        function oneClickOpt() {
            const obj = getJson();
            if (!obj) return;

            // 基础数值
            obj.gold = 999;
            obj.red = 10;
            obj.max_health = 99;
            obj.current_health = 99;

            // 遗物和钥匙
            relicLists.forEach(list => {
                if (!Array.isArray(obj[list])) obj[list] = [];
            });
            targetRelics.forEach(relic => !obj.relics.includes(relic) && obj.relics.push(relic));
            
            if (!Array.isArray(obj.relic_counters)) obj.relic_counters = [];
            while (obj.relic_counters.length < obj.relics.length) {
                obj.relic_counters.push(-1);
            }
            
            Object.entries(countRelics).forEach(([name, count]) => {
                const idx = obj.relics.indexOf(name);
                if (idx !== -1) obj.relic_counters[idx] = count;
            });
            
            relicLists.slice(1).forEach(list => {
                obj[list] = obj[list].filter(item => !targetRelics.includes(item));
            });
            
            obj.has_ruby_key = true;
            obj.has_emerald_key = true;
            obj.has_sapphire_key = true;

            // 卡牌处理
            if (!Array.isArray(obj.cards)) obj.cards = [];
            obj.cards = obj.cards.filter(card => !curseIds.includes(card.id));
            obj.cards.forEach(card => card.upgrades = 1);

            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 删除基础攻击卡
        function delAttack() {
            const obj = getJson();
            if (!obj) return;
            if (!Array.isArray(obj.cards)) obj.cards = [];
            obj.cards = obj.cards.filter(card => !attackIds.includes(card.id));
            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 删除基础防御卡
        function delDefend() {
            const obj = getJson();
            if (!obj) return;
            if (!Array.isArray(obj.cards)) obj.cards = [];
            obj.cards = obj.cards.filter(card => !defendIds.includes(card.id));
            outputEl.value = JSON.stringify(obj, null, 2);
        }

        // 下载修改后的存档文件
        function downloadFile() {
            const modified = outputEl.value.trim();
            if (!modified) return showAlert('无修改内容');
            if (!originalFileName) return showAlert('请先上传文件');
            try {
                const content = isEncrypted ? encode(modified) : modified;
                const blobType = isEncrypted ? 'text/plain;charset=utf-8' : 'application/json;charset=utf-8';
                const blob = new Blob([content], { type: blobType });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = originalFileName;
                a.click();
                URL.revokeObjectURL(a.href);
                showAlert('下载成功');
            } catch (e) {
                showAlert(`下载失败：${e.message}`);
            }
        }

        // 复制修改后的结果
        function copyResult() {
            const val = outputEl.value.trim();
            if (!val) return showAlert('无内容可复制');
            navigator.clipboard.writeText(val).then(() => {
                showAlert('复制成功');
            }).catch(() => {
                outputEl.select();
                document.execCommand('copy');
                showAlert('复制成功');
            });
        }
    </script>
</body>
</html>
